<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Enhanced Voice Chat</title>
  <style>
    :root {
      --primary-color: #4a6fa5;
      --secondary-color: #166088;
      --success-color: #28a745;
      --warning-color: #ffc107;
      --danger-color: #dc3545;
      --light-color: #f8f9fa;
      --dark-color: #343a40;
    }
    
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      line-height: 1.6;
      color: var(--dark-color);
      background-color: #f5f7fa;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    
    .container {
      width: 100%;
      max-width: 600px;
      background-color: white;
      border-radius: 10px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      padding: 30px;
      margin-top: 20px;
    }
    
    header {
      text-align: center;
      margin-bottom: 25px;
    }
    
    h1 {
      color: var(--primary-color);
      font-size: 2rem;
      margin-bottom: 10px;
    }
    
    .subtitle {
      color: var(--secondary-color);
      font-size: 1rem;
    }
    
    .room-controls {
      display: flex;
      flex-direction: column;
      gap: 15px;
      margin-bottom: 20px;
    }
    
    .input-group {
      display: flex;
      gap: 10px;
    }
    
    input, select {
      flex: 1;
      padding: 12px;
      border: 1px solid #ddd;
      border-radius: 5px;
      font-size: 1rem;
    }
    
    button {
      padding: 12px 20px;
      background-color: var(--primary-color);
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 1rem;
      transition: all 0.2s;
    }
    
    button:hover {
      background-color: var(--secondary-color);
    }
    
    button:active {
      transform: scale(0.98);
    }
    
    button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    
    .btn-success {
      background-color: var(--success-color);
    }
    
    .btn-success:hover {
      background-color: #218838;
    }
    
    .btn-danger {
      background-color: var(--danger-color);
    }
    
    .btn-danger:hover {
      background-color: #c82333;
    }
    
    #status {
      padding: 15px;
      border-radius: 5px;
      margin: 15px 0;
      text-align: center;
      font-weight: 500;
      display: none;
    }
    
    .status-success {
      background-color: rgba(40, 167, 69, 0.1);
      color: var(--success-color);
      display: block !important;
    }
    
    .status-warning {
      background-color: rgba(255, 193, 7, 0.1);
      color: #856404;
      display: block !important;
    }
    
    .status-error {
      background-color: rgba(220, 53, 69, 0.1);
      color: var(--danger-color);
      display: block !important;
    }
    
    .connection-info {
      background-color: #e9ecef;
      padding: 15px;
      border-radius: 5px;
      margin-bottom: 20px;
      display: none;
    }
    
    .room-info {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 10px;
    }
    
    .room-code {
      font-weight: bold;
      font-family: monospace;
      font-size: 1.2rem;
    }
    
    .copy-btn {
      background: none;
      color: var(--primary-color);
      padding: 5px 10px;
      font-size: 0.9rem;
    }
    
    .copy-btn:hover {
      background-color: rgba(74, 111, 165, 0.1);
    }
    
    .audio-controls {
      margin-top: 20px;
      display: none;
    }
    
    .control-group {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }
    
    .volume-control {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .volume-slider {
      width: 100px;
    }
    
    .voice-indicator {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .indicator {
      width: 15px;
      height: 15px;
      border-radius: 50%;
      background-color: #ccc;
      transition: all 0.2s;
      position: relative;
    }
    
    .indicator.active {
      background-color: var(--success-color);
    }
    
    .indicator.active::after {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      border-radius: 50%;
      border: 2px solid var(--success-color);
      animation: pulse 1.5s infinite;
    }
    
    .muted-indicator {
      width: 15px;
      height: 15px;
      border-radius: 50%;
      background-color: var(--danger-color);
      position: relative;
    }
    
    .muted-indicator::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 0;
      right: 0;
      height: 2px;
      background-color: white;
      transform: rotate(45deg);
    }
    
    .connection-status {
      display: flex;
      justify-content: space-between;
      margin-top: 15px;
    }
    
    .status-item {
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 0.9rem;
    }
    
    .status-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background-color: #ccc;
    }
    
    .status-dot.connected {
      background-color: var(--success-color);
    }
    
    .status-dot.disconnected {
      background-color: var(--danger-color);
    }
    
    .status-dot.connecting {
      background-color: var(--warning-color);
      animation: blink 1s infinite;
    }
    
    .connection-stats {
      margin-top: 15px;
      font-size: 0.9rem;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }
    
    .connection-stats div {
      display: flex;
      justify-content: space-between;
    }
    
    .session-timer {
      margin-top: 10px;
      font-size: 0.9rem;
      display: flex;
      justify-content: space-between;
    }
    
    .audio-visualizer {
      margin-top: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .audio-visualizer canvas {
      width: 100%;
      height: 40px;
      background-color: #f0f0f0;
      border-radius: 5px;
    }
    
    .recording-controls {
      display: flex;
      gap: 10px;
      margin-top: 15px;
    }
    
    #recordingStatus {
      margin-top: 10px;
      padding: 10px;
      background-color: rgba(40, 167, 69, 0.1);
      border-radius: 5px;
      display: none;
    }
    
    .call-summary {
      background-color: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      margin-top: 20px;
      width: 100%;
      max-width: 600px;
      display: none;
    }
    
    .call-summary h3 {
      margin-bottom: 15px;
      color: var(--primary-color);
    }
    
    #summaryDetails {
      margin-bottom: 15px;
    }
    
    .device-selection {
      margin-bottom: 15px;
      display: none;
    }
    
    .device-selector {
      padding: 8px;
      border-radius: 5px;
      border: 1px solid #ddd;
      width: 100%;
      margin-top: 5px;
    }
    
    .notification {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background-color: var(--primary-color);
      color: white;
      padding: 15px;
      border-radius: 5px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
      z-index: 1000;
      animation: slideIn 0.5s forwards;
    }
    
    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    @keyframes pulse {
      0% { transform: scale(1); opacity: 1; }
      70% { transform: scale(1.3); opacity: 0.7; }
      100% { transform: scale(1); opacity: 0; }
    }
    
    @keyframes slideIn {
      from { transform: translateX(100%); }
      to { transform: translateX(0); }
    }
    
    @media (max-width: 600px) {
      .container {
        padding: 20px;
      }
      
      h1 {
        font-size: 1.5rem;
      }
      
      .input-group {
        flex-direction: column;
      }
      
      button {
        width: 100%;
      }
      
      .control-group {
        flex-direction: column;
        align-items: flex-start;
        gap: 10px;
      }
      
      .voice-indicator {
        width: 100%;
        justify-content: space-between;
      }
      
      .audio-visualizer canvas {
        height: 30px;
      }
      
      input, select, textarea {
        font-size: 16px;
      }
      
      button, input[type="range"] {
        min-height: 44px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Enhanced Voice Chat</h1>
      <p class="subtitle">Simple, secure, real-time voice communication</p>
    </header>
    
    <div class="room-controls">
      <div class="input-group">
        <button id="createBtn">Create Room</button>
        <button id="leaveBtn" disabled>Leave Room</button>
      </div>
      <div class="input-group">
        <input type="text" id="roomCode" placeholder="Enter Room Code" />
        <button id="joinBtn">Join Room</button>
      </div>
    </div>
    
    <div id="deviceSelection" class="device-selection">
      <label for="audioInput">Microphone:</label>
      <select id="audioInput" class="device-selector"></select>
    </div>
    
    <div id="status"></div>
    
    <div id="connectionInfo" class="connection-info">
      <div class="room-info">
        <div>Room Code: <span id="currentRoom" class="room-code"></span></div>
        <button id="copyBtn" class="copy-btn">Copy</button>
      </div>
      <div class="connection-status">
        <div class="status-item">
          <span class="status-dot" id="localStatus"></span>
          <span>You</span>
        </div>
        <div class="status-item">
          <span class="status-dot" id="remoteStatus"></span>
          <span>Peer</span>
        </div>
      </div>
      <div class="connection-stats">
        <div><span>Connection:</span> <span id="connectionType">--</span></div>
        <div><span>Latency:</span> <span id="connectionLatency">--</span>ms</div>
        <div><span>Packet Loss:</span> <span id="packetLoss">--</span>%</div>
        <div><span>Bandwidth:</span> <span id="bandwidth">--</span>kbps</div>
      </div>
      <div class="session-timer">
        <span>Call Duration:</span>
        <span id="callTimer">00:00:00</span>
      </div>
    </div>
    
    <div id="audioControls" class="audio-controls">
      <div class="control-group">
        <button id="muteBtn">Mute Microphone</button>
        <div class="voice-indicator">
          <span>Your Voice:</span>
          <div id="localIndicator" class="indicator"></div>
        </div>
      </div>
      <div class="control-group">
        <div class="volume-control">
          <span>Volume:</span>
          <input type="range" id="volumeSlider" class="volume-slider" min="0" max="1" step="0.1" value="1">
        </div>
        <div class="voice-indicator">
          <span>Peer Voice:</span>
          <div id="remoteIndicator" class="indicator"></div>
        </div>
      </div>
      
      <div class="audio-visualizer">
        <canvas id="localVisualizer" width="200" height="40"></canvas>
        <canvas id="remoteVisualizer" width="200" height="40"></canvas>
      </div>
      
      <div class="recording-controls">
        <button id="startRecording">Start Recording</button>
        <button id="stopRecording" disabled>Stop Recording</button>
      </div>
      <div id="recordingStatus"></div>
    </div>
    
    <div id="callSummary" class="call-summary">
      <h3>Call Summary</h3>
      <div id="summaryDetails"></div>
      <button id="closeSummary">Close</button>
    </div>
  </div>
  
  <footer>
    <p>&copy; 2025 Enhanced Voice Chat</p>
  </footer>

  <script src="/socket.io/socket.io.js"></script>
<script>
  document.addEventListener('DOMContentLoaded', () => {
    // Enhanced configuration with fallback STUN servers
    const config = {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' },
        { urls: 'stun:stun2.l.google.com:19302' },
        { urls: 'stun:stun3.l.google.com:19302' },
        { urls: 'stun:stun4.l.google.com:19302' }
        // Add your TURN server configuration here if available
      ],
      iceCandidatePoolSize: 10,
      bundlePolicy: 'max-bundle',
      rtcpMuxPolicy: 'require'
    };

    // State management with enhanced defaults
    const state = {
      socket: null,
      localStream: null,
      peerConnection: null,
      remoteAudio: null,
      room: null,
      isCaller: false,
      isConnected: false,
      isMuted: false,
      localAnalyser: null,
      remoteAnalyser: null,
      audioContext: null,
      audioInputDevices: [],
      mediaRecorder: null,
      recordedChunks: [],
      recordingStartTime: null,
      callTimerInterval: null,
      callStartTime: null,
      connectionTimeout: null,
      reconnectAttempts: 0,
      maxReconnectAttempts: 5,
      iceCandidates: []
    };

    // DOM Elements
    const elements = {
      createBtn: document.getElementById('createBtn'),
      joinBtn: document.getElementById('joinBtn'),
      leaveBtn: document.getElementById('leaveBtn'),
      roomInput: document.getElementById('roomCode'),
      status: document.getElementById('status'),
      connectionInfo: document.getElementById('connectionInfo'),
      currentRoom: document.getElementById('currentRoom'),
      copyBtn: document.getElementById('copyBtn'),
      audioControls: document.getElementById('audioControls'),
      muteBtn: document.getElementById('muteBtn'),
      volumeSlider: document.getElementById('volumeSlider'),
      localIndicator: document.getElementById('localIndicator'),
      remoteIndicator: document.getElementById('remoteIndicator'),
      localStatus: document.getElementById('localStatus'),
      remoteStatus: document.getElementById('remoteStatus'),
      audioInputSelect: document.getElementById('audioInput'),
      deviceSelection: document.getElementById('deviceSelection'),
      startRecordingBtn: document.getElementById('startRecording'),
      stopRecordingBtn: document.getElementById('stopRecording'),
      recordingStatus: document.getElementById('recordingStatus'),
      callSummary: document.getElementById('callSummary'),
      closeSummaryBtn: document.getElementById('closeSummary'),
      localVisualizer: document.getElementById('localVisualizer'),
      remoteVisualizer: document.getElementById('remoteVisualizer')
    };

    // Initialize Socket.IO connection with enhanced options
    function initializeSocket() {
      console.log('Initializing socket connection...');
      
      // Close existing connection if any
      if (state.socket) {
        state.socket.close();
      }
      
      state.socket = io({
        reconnectionAttempts: state.maxReconnectAttempts,
        reconnectionDelay: 1000,
        reconnectionDelayMax: 5000,
        timeout: 20000,
        transports: ['websocket']
      });
      
      // Socket event handlers with enhanced logging
      state.socket.on('connect', () => {
        console.log('Connected to signaling server');
        state.reconnectAttempts = 0;
        updateStatus('Connected to server', 'success');
        elements.localStatus.classList.add('connected');
        elements.localStatus.classList.remove('disconnected', 'connecting');
        
        // Rejoin room if we were in one before disconnect
        if (state.room) {
          console.log('Rejoining room after reconnect:', state.room);
          state.socket.emit('join', state.room, (response) => {
            if (!response.success) {
              console.error('Failed to rejoin room:', response.error);
              updateStatus(`Reconnect failed: ${response.error}`, 'error');
              cleanupPeerConnection();
              updateRoomUI(false);
              state.room = null;
            }
          });
        }
      });
      
      state.socket.on('disconnect', (reason) => {
        console.log('Disconnected from server. Reason:', reason);
        updateStatus('Disconnected from server', 'error');
        elements.localStatus.classList.remove('connected');
        elements.localStatus.classList.add('disconnected');
        
        // Only attempt to reconnect if we're not manually leaving
        if (state.room && reason !== 'io client disconnect') {
          attemptReconnect();
        }
      });
      
      state.socket.on('connect_error', (err) => {
        console.error('Connection error:', err.message);
        updateStatus(`Connection error: ${err.message}`, 'error');
      });
      
      state.socket.on('reconnect_attempt', (attempt) => {
        state.reconnectAttempts = attempt;
        console.log(`Reconnection attempt ${attempt}/${state.maxReconnectAttempts}`);
        updateStatus(`Connection lost. Reconnecting (${attempt}/${state.maxReconnectAttempts})...`, 'warning');
        elements.localStatus.classList.remove('connected');
        elements.localStatus.classList.add('connecting');
      });
      
      state.socket.on('reconnect_failed', () => {
        console.error('Reconnection failed after maximum attempts');
        updateStatus('Failed to reconnect. Please refresh the page.', 'error');
      });
      
      // Enhanced room event handlers
      state.socket.on('created', handleRoomCreated);
      state.socket.on('joined', handleRoomJoined);
      state.socket.on('full', handleRoomFull);
      state.socket.on('peer_joined', handlePeerJoined);
      state.socket.on('ready', handlePeerReady);
      state.socket.on('offer', handleOffer);
      state.socket.on('answer', handleAnswer);
      state.socket.on('ice', handleIceCandidate);
      state.socket.on('leave', handlePeerLeave);
      state.socket.on('error', handleError);
      state.socket.on('recording_notification', handleRecordingNotification);
      state.socket.on('offline_message', handleOfflineMessage);
      state.socket.on('pending_messages', handlePendingMessages);
    }
    
    // Attempt to reconnect with backoff
    function attemptReconnect() {
      if (state.reconnectAttempts < state.maxReconnectAttempts) {
        const delay = Math.min(1000 * Math.pow(2, state.reconnectAttempts), 10000);
        console.log(`Will attempt reconnect in ${delay}ms`);
        setTimeout(initializeSocket, delay);
      }
    }

    // Room event handlers
    function handleRoomCreated(roomId) {
      console.log('Room created:', roomId);
      state.room = roomId;
      state.isCaller = true;
      updateRoomUI(true);
      updateStatus(`Room created with code: ${roomId}`, 'success');
      
      // Start device selection immediately for the creator
      getAudioDevices();
    }
    
    function handleRoomJoined(roomId) {
      console.log('Joined room:', roomId);
      state.room = roomId;
      state.isCaller = false;
      updateRoomUI(true);
      updateStatus('Joined room, waiting for connection...', 'warning');
      
      // Start device selection immediately for the joiner
      getAudioDevices();
    }
    
    function handlePeerJoined() {
      console.log('Peer joined the room');
      updateStatus('Peer joined, establishing connection...', 'warning');
    }
    
    function handleRoomFull() {
      console.log('Room is full');
      updateStatus('Room is full. Please try a different code.', 'error');
    }
    
    function handlePeerReady() {
      console.log('Peer is ready, isCaller:', state.isCaller);
      if (state.isCaller) {
        elements.remoteStatus.classList.add('connecting');
        startCall(true);
      }
    }
    
    function handlePeerLeave() {
      console.log('Peer left the room');
      updateStatus('Peer has left the room', 'warning');
      cleanupPeerConnection();
      elements.remoteStatus.classList.remove('connected', 'connecting');
      elements.remoteStatus.classList.add('disconnected');
    }
    
    function handleError(error) {
      console.error('Server error:', error);
      updateStatus(`Error: ${error}`, 'error');
    }
    
    function handleRecordingNotification(message) {
      console.log('Recording notification:', message);
      showNotification(message);
    }
    
    function handleOfflineMessage({ from, message }) {
      console.log('Offline message received from:', from);
      showNotification(`Offline message: ${message}`);
    }
    
    function handlePendingMessages(messages) {
      console.log('Pending messages:', messages.length);
      if (messages.length) {
        showNotification(`You have ${messages.length} pending message(s)`);
      }
    }

    // WebRTC functions with enhanced error handling
    async function startCall(shouldMakeOffer, deviceId = null) {
      console.log('Starting call, shouldMakeOffer:', shouldMakeOffer);
      
      // Clear any existing timeout
      clearTimeout(state.connectionTimeout);
      
      // Set connection timeout (30 seconds)
      state.connectionTimeout = setTimeout(() => {
        if (!state.isConnected) {
          console.error('Connection timed out');
          updateStatus('Connection timed out. Please try again.', 'error');
          cleanupPeerConnection();
        }
      }, 30000);
      
      try {
        const constraints = {
          audio: {
            deviceId: deviceId ? { exact: deviceId } : undefined,
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true
          },
          video: false
        };
        
        // Get user media with fallback for deviceId issues
        try {
          state.localStream = await navigator.mediaDevices.getUserMedia(constraints);
        } catch (err) {
          console.warn('Failed to get media with deviceId, trying without:', err);
          delete constraints.audio.deviceId;
          state.localStream = await navigator.mediaDevices.getUserMedia(constraints);
        }
        
        // Create peer connection with enhanced error handling
        try {
          state.peerConnection = new RTCPeerConnection(config);
          console.log('Created new RTCPeerConnection');
        } catch (err) {
          throw new Error(`Failed to create peer connection: ${err.message}`);
        }
        
        // Add local tracks to peer connection
        state.localStream.getTracks().forEach(track => {
          state.peerConnection.addTrack(track, state.localStream);
        });
        
        // Set up event handlers
        state.peerConnection.onicecandidate = handleLocalIceCandidate;
        state.peerConnection.ontrack = handleRemoteTrack;
        state.peerConnection.oniceconnectionstatechange = handleConnectionStateChange;
        state.peerConnection.onicegatheringstatechange = handleIceGatheringStateChange;
        state.peerConnection.onsignalingstatechange = handleSignalingStateChange;
        state.peerConnection.onnegotiationneeded = handleNegotiationNeeded;
        
        // Set up audio analysis
        setupAudioAnalysis();
        
        // Create and send offer if initiator
        if (shouldMakeOffer) {
          try {
            const offer = await state.peerConnection.createOffer({
              offerToReceiveAudio: true,
              offerToReceiveVideo: false
            });
            console.log('Created offer:', offer);
            
            await state.peerConnection.setLocalDescription(offer);
            console.log('Set local description:', state.peerConnection.localDescription);
            
            state.socket.emit('offer', { room: state.room, offer }, (response) => {
              if (!response.success) {
                throw new Error(response.error || 'Failed to send offer');
              }
              console.log('Offer successfully sent to peer');
            });
          } catch (err) {
            throw new Error(`Failed to create/send offer: ${err.message}`);
          }
        }
        
        // Show audio controls and device selection
        elements.audioControls.style.display = 'block';
        
        // Notify that call is connected
        state.socket.emit('call_connected', state.room, (response) => {
          if (!response.success) {
            console.error('Failed to notify call connection:', response.error);
          }
        });
        
      } catch (error) {
        console.error('Error starting call:', error);
        updateStatus(`Call failed: ${error.message}`, 'error');
        cleanupPeerConnection();
      }
    }
    
    async function handleOffer({ offer }) {
      console.log('Received offer:', offer);
      try {
        if (!state.peerConnection) {
          elements.remoteStatus.classList.add('connecting');
          await startCall(false);
        }
        
        if (!offer.type || !offer.sdp) {
          throw new Error('Invalid offer format');
        }
        
        await state.peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
        console.log('Set remote description (offer):', offer);
        
        const answer = await state.peerConnection.createAnswer({
          offerToReceiveAudio: true,
          offerToReceiveVideo: false
        });
        console.log('Created answer:', answer);
        
        await state.peerConnection.setLocalDescription(answer);
        console.log('Set local description (answer):', state.peerConnection.localDescription);
        
        state.socket.emit('answer', { room: state.room, answer }, (response) => {
          if (!response.success) {
            throw new Error(response.error || 'Failed to send answer');
          }
          console.log('Answer successfully sent to peer');
        });
        
      } catch (error) {
        console.error('Error handling offer:', error);
        updateStatus(`Failed to process connection offer: ${error.message}`, 'error');
        cleanupPeerConnection();
      }
    }
    
    function handleAnswer({ answer }) {
      console.log('Received answer:', answer);
      if (!state.peerConnection) {
        console.error('No peer connection when receiving answer');
        return;
      }
      
      if (!answer.type || !answer.sdp) {
        console.error('Invalid answer format');
        return;
      }
      
      state.peerConnection.setRemoteDescription(new RTCSessionDescription(answer))
        .then(() => {
          console.log('Set remote description (answer):', answer);
        })
        .catch(error => {
          console.error('Error setting remote description:', error);
          updateStatus('Failed to process connection answer', 'error');
        });
    }
    
    function handleLocalIceCandidate(event) {
      if (event.candidate) {
        console.log('Generated ICE candidate:', event.candidate);
        state.socket.emit('ice', { room: state.room, candidate: event.candidate }, (response) => {
          if (!response.success) {
            console.error('Failed to send ICE candidate:', response.error);
          }
        });
      } else {
        console.log('ICE gathering complete');
      }
    }
    
    function handleIceCandidate({ candidate }) {
      console.log('Received remote ICE candidate:', candidate);
      if (!state.peerConnection) {
        console.log('No peer connection, storing ICE candidate');
        state.iceCandidates.push(candidate);
        return;
      }
      
      state.peerConnection.addIceCandidate(new RTCIceCandidate(candidate))
        .then(() => {
          console.log('Successfully added ICE candidate');
          // Process any stored candidates
          processStoredIceCandidates();
        })
        .catch(error => {
          console.error('Error adding ICE candidate:', error);
        });
    }
    
    function processStoredIceCandidates() {
      while (state.iceCandidates.length > 0 && state.peerConnection) {
        const candidate = state.iceCandidates.shift();
        state.peerConnection.addIceCandidate(new RTCIceCandidate(candidate))
          .catch(error => {
            console.error('Error adding stored ICE candidate:', error);
          });
      }
    }
    
    function handleRemoteTrack(event) {
      console.log('Received remote track');
      if (!event.streams || event.streams.length === 0) {
        console.error('No streams in track event');
        return;
      }
      
      state.remoteAudio = new Audio();
      state.remoteAudio.srcObject = event.streams[0];
      state.remoteAudio.autoplay = true;
      state.remoteAudio.volume = elements.volumeSlider.value;
      
      // Set up voice activity detection for remote stream
      setupRemoteVoiceActivity(event.streams[0]);
      
      // Update UI
      state.isConnected = true;
      clearTimeout(state.connectionTimeout);
      elements.remoteStatus.classList.remove('connecting');
      elements.remoteStatus.classList.add('connected');
      updateStatus('Connected! You can now speak with your peer.', 'success');
      
      // Start connection stats monitoring
      startConnectionStats();
      
      // Start call timer
      startCallTimer();
    }
    
    function handleConnectionStateChange() {
      if (!state.peerConnection) return;
      
      const stateStr = state.peerConnection.iceConnectionState;
      console.log('ICE connection state changed:', stateStr);
      
      switch(stateStr) {
        case 'checking':
          updateStatus('Connecting to peer...', 'warning');
          break;
        case 'connected':
        case 'completed':
          state.isConnected = true;
          clearTimeout(state.connectionTimeout);
          updateStatus('Connected!', 'success');
          elements.remoteStatus.classList.remove('connecting');
          elements.remoteStatus.classList.add('connected');
          break;
        case 'disconnected':
          updateStatus('Connection lost, attempting to reconnect...', 'warning');
          break;
        case 'failed':
          updateStatus('Connection failed', 'error');
          cleanupPeerConnection();
          break;
        case 'closed':
          updateStatus('Connection closed', 'warning');
          cleanupPeerConnection();
          break;
      }
    }
    
    function handleIceGatheringStateChange() {
      if (!state.peerConnection) return;
      console.log('ICE gathering state:', state.peerConnection.iceGatheringState);
    }
    
    function handleSignalingStateChange() {
      if (!state.peerConnection) return;
      console.log('Signaling state:', state.peerConnection.signalingState);
    }
    
    function handleNegotiationNeeded() {
      console.log('Negotiation needed');
      // Implement renegotiation logic if needed
    }

    // Audio analysis and visualization
    function setupAudioAnalysis() {
      if (!state.audioContext) {
        try {
          state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
          console.log('Created audio context');
        } catch (err) {
          console.error('Error creating audio context:', err);
          return;
        }
      }
      
      // Local audio analysis
      const localSource = state.audioContext.createMediaStreamSource(state.localStream);
      state.localAnalyser = state.audioContext.createAnalyser();
      state.localAnalyser.fftSize = 256;
      localSource.connect(state.localAnalyser);
      
      const localData = new Uint8Array(state.localAnalyser.frequencyBinCount);
      
      function checkLocalVolume() {
        if (!state.localAnalyser) return;
        
        state.localAnalyser.getByteFrequencyData(localData);
        const average = localData.reduce((sum, value) => sum + value, 0) / localData.length;
        
        if (average > 15 && !state.isMuted) {
          elements.localIndicator.classList.add('active');
        } else {
          elements.localIndicator.classList.remove('active');
        }
        
        requestAnimationFrame(checkLocalVolume);
      }
      
      checkLocalVolume();
      setupAudioVisualizers();
    }
    
    function setupRemoteVoiceActivity(stream) {
      const remoteSource = state.audioContext.createMediaStreamSource(stream);
      state.remoteAnalyser = state.audioContext.createAnalyser();
      state.remoteAnalyser.fftSize = 256;
      remoteSource.connect(state.remoteAnalyser);
      
      const remoteData = new Uint8Array(state.remoteAnalyser.frequencyBinCount);
      
      function checkRemoteVolume() {
        if (!state.remoteAnalyser) return;
        
        state.remoteAnalyser.getByteFrequencyData(remoteData);
        const average = remoteData.reduce((sum, value) => sum + value, 0) / remoteData.length;
        
        if (average > 15) {
          elements.remoteIndicator.classList.add('active');
        } else {
          elements.remoteIndicator.classList.remove('active');
        }
        
        requestAnimationFrame(checkRemoteVolume);
      }
      
      checkRemoteVolume();
      setupAudioVisualizers();
    }
    
    function setupAudioVisualizers() {
      const localCanvas = elements.localVisualizer;
      const remoteCanvas = elements.remoteVisualizer;
      
      const localCtx = localCanvas.getContext('2d');
      const remoteCtx = remoteCanvas.getContext('2d');
      
      function drawVisualizer(analyser, canvas, ctx) {
        if (!analyser) return;
        
        const bufferLength = analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        
        function draw() {
          requestAnimationFrame(draw);
          
          analyser.getByteFrequencyData(dataArray);
          
          ctx.fillStyle = 'rgb(20, 20, 20)';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          const barWidth = (canvas.width / bufferLength) * 2.5;
          let x = 0;
          
          for (let i = 0; i < bufferLength; i++) {
            const barHeight = (dataArray[i] / 255) * canvas.height;
            
            ctx.fillStyle = `rgb(${barHeight + 100}, 50, 50)`;
            ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
            
            x += barWidth + 1;
          }
        }
        
        draw();
      }
      
      drawVisualizer(state.localAnalyser, localCanvas, localCtx);
      drawVisualizer(state.remoteAnalyser, remoteCanvas, remoteCtx);
    }

    // Device management
    async function getAudioDevices() {
      try {
        // First get permission by accessing media devices
        await navigator.mediaDevices.getUserMedia({ audio: true });
        
        const devices = await navigator.mediaDevices.enumerateDevices();
        state.audioInputDevices = devices.filter(device => device.kind === 'audioinput');
        
        elements.audioInputSelect.innerHTML = '';
        
        state.audioInputDevices.forEach(device => {
          const option = document.createElement('option');
          option.value = device.deviceId;
          option.text = device.label || `Microphone ${elements.audioInputSelect.length + 1}`;
          elements.audioInputSelect.appendChild(option);
        });
        
        elements.deviceSelection.style.display = 'block';
      } catch (error) {
        console.error('Error enumerating devices:', error);
        updateStatus('Could not access microphone devices. Please check permissions.', 'warning');
      }
    }

    // Clean up resources
    function cleanupPeerConnection() {
      console.log('Cleaning up peer connection');
      
      // Clear timers
      clearTimeout(state.connectionTimeout);
      stopCallTimer();
      
      // Close peer connection
      if (state.peerConnection) {
        state.peerConnection.onicecandidate = null;
        state.peerConnection.ontrack = null;
        state.peerConnection.oniceconnectionstatechange = null;
        state.peerConnection.onicegatheringstatechange = null;
        state.peerConnection.onsignalingstatechange = null;
        state.peerConnection.onnegotiationneeded = null;
        state.peerConnection.close();
        state.peerConnection = null;
      }
      
      // Stop local stream
      if (state.localStream) {
        state.localStream.getTracks().forEach(track => track.stop());
        state.localStream = null;
      }
      
      // Clean up remote audio
      if (state.remoteAudio) {
        state.remoteAudio.srcObject = null;
        state.remoteAudio = null;
      }
      
      // Stop any recording
      if (state.mediaRecorder && state.mediaRecorder.state !== 'inactive') {
        state.mediaRecorder.stop();
      }
      
      // Reset audio context
      if (state.audioContext) {
        if (state.audioContext.state !== 'closed') {
          state.audioContext.close();
        }
        state.audioContext = null;
      }
      
      // Reset state
      state.isConnected = false;
      state.localAnalyser = null;
      state.remoteAnalyser = null;
      state.iceCandidates = [];
      
      // Hide audio controls
      elements.audioControls.style.display = 'none';
    }
    
    function leaveRoom() {
      if (state.room) {
        console.log('Leaving room:', state.room);
        showCallSummary();
        state.socket.emit('leave', state.room, (response) => {
          if (!response.success) {
            console.error('Failed to notify server about leaving:', response.error);
          }
        });
        cleanupPeerConnection();
        state.room = null;
        updateRoomUI(false);
        updateStatus('You left the room', 'warning');
      }
    }

    // Event listeners
    elements.createBtn.addEventListener('click', () => {
      const randomRoom = Math.random().toString(36).substring(2, 8).toUpperCase();
      updateStatus(`Creating room ${randomRoom}...`, 'warning');
      
      state.socket.emit('create', randomRoom, (response) => {
        if (!response.success) {
          updateStatus(`Failed to create room: ${response.error}`, 'error');
        }
      });
    });
    
    elements.joinBtn.addEventListener('click', () => {
      const roomCode = elements.roomInput.value.trim();
      if (!roomCode) {
        updateStatus('Please enter a room code', 'warning');
        return;
      }
      
      updateStatus(`Joining room ${roomCode}...`, 'warning');
      state.socket.emit('join', roomCode, (response) => {
        if (!response.success) {
          updateStatus(`Failed to join room: ${response.error}`, 'error');
        }
      });
    });
    
    elements.leaveBtn.addEventListener('click', () => {
      if (state.isConnected) {
        if (confirm('Are you sure you want to end the call?')) {
          leaveRoom();
        }
      } else {
        leaveRoom();
      }
    });
    
    elements.muteBtn.addEventListener('click', () => {
      if (!state.localStream) return;
      
      state.isMuted = !state.isMuted;
      state.localStream.getAudioTracks().forEach(track => {
        track.enabled = !state.isMuted;
      });
      
      elements.muteBtn.textContent = state.isMuted ? 'Unmute Microphone' : 'Mute Microphone';
      showNotification(state.isMuted ? 'Microphone muted' : 'Microphone unmuted');
    });
    
    elements.volumeSlider.addEventListener('input', () => {
      if (state.remoteAudio) {
        state.remoteAudio.volume = elements.volumeSlider.value;
      }
    });
    
    elements.copyBtn.addEventListener('click', () => {
      navigator.clipboard.writeText(state.room)
        .then(() => {
          elements.copyBtn.textContent = 'Copied!';
          setTimeout(() => {
            elements.copyBtn.textContent = 'Copy';
          }, 2000);
          showNotification('Room code copied to clipboard');
        })
        .catch(err => {
          console.error('Failed to copy room code:', err);
          updateStatus('Failed to copy room code', 'error');
        });
    });
    
    elements.audioInputSelect.addEventListener('change', (e) => {
      if (state.room && state.localStream) {
        const deviceId = e.target.value;
        leaveRoom();
        setTimeout(() => {
          state.socket.emit('join', state.room, (response) => {
            if (response.success) {
              startCall(state.isCaller, deviceId);
            }
          });
        }, 500);
      }
    });
    
    elements.startRecordingBtn.addEventListener('click', startRecording);
    elements.stopRecordingBtn.addEventListener('click', stopRecording);
    elements.closeSummaryBtn.addEventListener('click', () => {
      elements.callSummary.style.display = 'none';
    });
    
    // Handle window unload
    window.addEventListener('beforeunload', () => {
      if (state.room) {
        // Try to send leave message, but don't wait for it
        state.socket.emit('leave', state.room);
      }
    });
    
    // Request notification permission on page load
    if ("Notification" in window && Notification.permission !== "granted") {
      Notification.requestPermission();
    }
    
    // Initialize
    initializeSocket();
  });
</script>
</body>
</html>
